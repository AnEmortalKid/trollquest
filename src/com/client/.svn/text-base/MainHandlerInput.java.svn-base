package com.client;

import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.LinkedList;
import java.util.Observable;
import java.util.Observer;
import java.util.concurrent.ConcurrentHashMap;

import com.client.GUI.Controls;
import com.client.GUI.panels.GUIPanels;
import com.client.GUI.panels.player.GUIPanelPlayerSpells;
import com.client.Graphics.GraphicsAbstract;
import com.client.Graphics.AnimationsOfACharacter.ActionType;
import com.client.Main.MoveType;
import com.game.characters.Creature;
import com.game.characters.GameCharacter;
import com.game.environment.Directions;
import com.game.environment.tiles.Tile;
import com.server.command.AttackCommand;
import com.server.command.CommandChangeState;
import com.server.command.ComparableCommand;
import com.server.command.DieCommand;
import com.server.command.MoveCommand;
import com.server.command.PlayerDataCommand;
import com.server.command.PlayerQuitCommand;
import com.server.command.RespawnCommand;
import com.server.command.SendProfileCommand;
import com.server.command.SingleStepCommand;
import com.server.factory.classes.DebugClientListener;
import com.utilities.DijkstraMap;
import com.utilities.MutableInteger;

/**
 * Handles all the input generated.
 * 
 * @author Ian
 */
public class MainHandlerInput implements Observer {
	/** The instance. */
	private static MainHandlerInput instance = null;
	/** The state of the keys we've hit. */
	public final static ConcurrentHashMap<Integer, Boolean> keys = new ConcurrentHashMap<Integer, Boolean>();

	/** The current move path generated by the user. */
	public final static LinkedList<Tile> move_path = new LinkedList<Tile>();
	/** The command that we should be expecting back from the server next. */
	private static ComparableCommand command_current = null; // Needed for the observer update.
	/** The commands to send next. */
	public final static LinkedList<ComparableCommand> command_queue = new LinkedList<ComparableCommand>();
	
	private final static DijkstraMap dijkstraMap = new DijkstraMap();

	/** The constructor. */
	private MainHandlerInput() {
		((DebugClientListener) Main.client).addObserver(this);
	}

	/** Returns the instance of the handler. Using singleton pattern. */
	public static MainHandlerInput getInstance() {
		if (instance == null)
			instance = new MainHandlerInput();
		return instance;
	}

	/** Send the first command in the queue. */
	public final static void sendFirst() {
		synchronized (command_queue) {
			if (command_queue.isEmpty()) return;
			if (command_current != null) {
				System.err.println("Waiting on another command \""+command_current+"\"!");
				return;
			}
			ComparableCommand cmd = command_queue.removeFirst();
			command_current = cmd;
			// System.out.println("###############SENDING############### "+cmd);
			Main.sendCommand(cmd);
		}
	}

	/** Kill all the queued commands. */
	private final static void killQueued() {
		synchronized (command_queue) {
			command_queue.clear();
			synchronized (Main.getState()) {
				command_queue.add(new CommandChangeState(Main.player_name,
						ActionType.STAND, Main.getSelf().getDirection(), 0.0,
						0.0));
			}
		}
	}

	/** Adds the path to the queued commands. */
	private final static void addPath() {
		synchronized(move_path) { synchronized (Main.getState()) {
			GameCharacter self = Main.getSelf();
			if (self==null) return;
			if (move_path.size() == 0) {
				if (Main.move_type == MoveType.MOVE_TO_CAST) {
					command_queue.add(GUIPanelPlayerSpells.castSomething(self.getPosition()));
				}
				return;
			}
			move_path.pop(); // do not need starting node.

			Tile tile_src;
			Tile tile_dst;


			tile_src = Main.getCurrentMap().getTile(self.getPosition().x,
					self.getPosition().y);

			int i = 0;
			for (Tile tile : move_path) {
				tile_dst = tile;
				Point new_pos = tile_dst.getPosition();
				
				Directions direction = Tile.getDirection(Tile.getDelta(tile_dst, tile_src));

				//System.out.println("################################"+tile.getOccupant()+" "+(tile.getOccupant() instanceof Creature)+" "+Main.move_type);
				if (tile_dst.getOccupant()!=null &&
					(tile_dst.getOccupant() instanceof Creature) &&
					Main.move_type==MoveType.MOVE_TO_ATTACK)
				{
					command_queue.add(new CommandChangeState(Main.player_name, ActionType.ATTACK, direction, 0.0, 0.0));
					command_queue.add(new AttackCommand(Main.getState(), Main.player_name, new_pos.x, new_pos.y));
				} else if (Main.move_type==MoveType.MOVE_TO_CAST && i==move_path.size()-1) {
					// command_queue.add( new
					// CommandChangeState(Main.player_name,ActionType.DIE,direction,0.0,0.0)
					// );
					command_queue.add(GUIPanelPlayerSpells.castSomething(new_pos));
				} else {
					double cost = Tile.getCost(tile_src, tile_dst);
					double velx = direction.subpos_delta.x / cost;
					double vely = direction.subpos_delta.y / cost;

					command_queue.add(new CommandChangeState(Main.player_name, ActionType.WALK, direction, velx, vely));
					command_queue.add(new MoveCommand(Main.player_name, new_pos.x, new_pos.y));
				}
				tile_src = tile_dst;
				++i;
			}
		}}
	}

	/** Updates the calculated path. */
	private final static void updatePath() {
		synchronized (move_path) {
			move_path.clear();
		}
		
		if (GUIPanels.hasActivePanel()) return;

		synchronized (command_queue) {
			synchronized (Main.getState()) {
				if (Main.getSelf() == null) return;
				if (command_queue.isEmpty() && Main.getSelf().getActionState() == ActionType.STAND) {
					MutableInteger tile_x = new MutableInteger(0), tile_y = new MutableInteger(0);
					if (GraphicsAbstract.convertMouseToMap(tile_x, tile_y)) {
						// tile_x.set(4); tile_y.set(2);
						GraphicsAbstract.tile_highlight.setPosition(new Point(tile_x.get(),tile_y.get()));

						Point pos = Main.getSelf().getPosition();
						Tile start = Main.getCurrentMap().getTile(pos.x, pos.y);
						Tile end = Main.getCurrentMap().getTile(tile_x.get(), tile_y.get());
						synchronized(move_path) {
							dijkstraMap.solve(Main.getCurrentMap(), start, end, move_path);

							if (!move_path.isEmpty()) {
								if (move_path.getLast().getOccupant()!=null&&Main.move_type==MoveType.MOVE) {
									//Disallow trying to move onto a square with something already on it.
									move_path.clear();
								}
							}
						}
					}
				}
			}
		}
	}

	/** Called whenever the mouse moves. Primarily updates the move path. */
	public final static void mouseMove(MouseEvent me) {
		try {
			GUIPanels.processMouseMove(me);
		} catch (ExceptionInInitializerError e) {
			e.getCause().printStackTrace();
		}
		if (Main.getSelf() != null && Main.getSelf().getActionState()==ActionType.DIE) return;
		updatePath();
	}
	/** Called whenever the mouse clicks. Primarily sends move commands. */
	public final static void mouseClick(MouseEvent me) {
		if (GUIPanels.processMouseClick(me)) return;

		if (Main.getSelf() == null) return;

		synchronized (Main.getSelf()) {
			if (Main.getSelf().getActionState()==ActionType.DIE) return;
			
			// if Main.getSelf().
			synchronized (command_queue) {
				if (command_queue.isEmpty()) {
					addPath();
				} else {
					synchronized (move_path) {
						move_path.clear();
					}
					killQueued();
				}
			}
		}

		sendFirst();
	}

	/** Called whenever a key is released. */
	public final static void keyReleased(KeyEvent ke) {
		int code = ke.getKeyCode();
		if (!keys.containsKey(code)) {
			keys.put(code, false);
		}

		//if (Main.getSelf()!=null && Main.getSelf().getActionState()==ActionType.STAND) {
		synchronized (Main.move_type) {
			switch (code) {
				case (Controls.HOLD_ATTACK):
					Main.move_type = MoveType.MOVE;
					//System.out.println("################################RESETTING TO MOVE");
					break;
				case (Controls.HOLD_CAST):
					Main.move_type = MoveType.MOVE;
					//System.out.println("################################RESETTING TO MOVE");
					break;
			}
		}
		//}

		updatePath();
	}
	/** Called whenever a key is pressed. */
	public final static void keyPressed(KeyEvent ke) {
		if (!GUIPanels.processKey(ke)) {
			int code = ke.getKeyCode();
			if (!keys.containsKey(code)) {
				keys.put(code, true);
			}

			synchronized (Main.move_type) {
				switch (code) {
					case (Controls.HOLD_ATTACK):
						//System.out.println("################################SETTING TO ATTACK");
						Main.move_type = MoveType.MOVE_TO_ATTACK;
						break;
					case (Controls.HOLD_CAST):
						//System.out.println("################################SETTING TO CAST");
						Main.move_type = MoveType.MOVE_TO_CAST;
						break;
					case (Controls.SERVER_STEP):
						Main.sendCommand(new SingleStepCommand());
						break;
					case (Controls.SELECT_SPELL_UP): GUIPanelPlayerSpells.selectUp(); break;
					case (Controls.SELECT_SPELL_DOWN): GUIPanelPlayerSpells.selectDown(); break;
				}
			}
		}

		updatePath();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override public final void update(Observable arg0, Object arg1) {
		// System.out.println("###############RECEIVING############### "+arg1);

		if (arg1 == null) return;
		ComparableCommand cmd = (ComparableCommand)(arg1);

		if (cmd instanceof SendProfileCommand) {
			SendProfileCommand cmd2 = (SendProfileCommand) (cmd);

			Main.userprofile = cmd2.getProfile();

			GUIPanels.openPanelCreate();
		} else if (cmd instanceof PlayerDataCommand) {
			if (!cmd.getSuccess()) {
				GUIPanels.openPanelCreate();
			}
		} else if (cmd instanceof MoveCommand) {
			synchronized (move_path) {
				if (!move_path.isEmpty()) {
					move_path.pop();
				}
			}
		} else if (cmd instanceof PlayerQuitCommand) {
			if (cmd.getCharName().equals(Main.player_name)) {
				System.exit(0);
			}
		} else if (cmd instanceof RespawnCommand || cmd instanceof DieCommand) {
			if (cmd.getCharName().equals(Main.player_name)) {
				killQueued();
				synchronized (move_path) {
					move_path.clear();
				}

				command_current = null;
				//System.out.println("################################SETTING TO MOVE IN DIE/RESPAWN");
				synchronized (Main.move_type) { Main.move_type = MoveType.MOVE; }
				//The RespawnCommand already does this.
				//command_queue.add(new CommandChangeState(Main.player_name, ActionType.STAND,Main.getSelf().getDirection(), 0.0, 0.0));
				sendFirst();
			}
		}

		if (cmd.equals(command_current)) {
			command_current = null;
			if (!cmd.getSuccess()) killQueued();
			sendFirst();
		}

		mouseMove(null); // To reset the paths
		/*synchronized (command_queue) {
			if (command_queue.isEmpty()) {
				if (Main.getSelf()!=null && Main.getSelf().getActionState()==ActionType.STAND) {
					//System.out.println("################################SETTING TO MOVE IN RESET");
					synchronized (Main.move_type) { Main.move_type = MoveType.MOVE; }
				}
			}
		}*/
	}
}